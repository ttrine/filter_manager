<library>
<note> Companies </note>
	<block name="synch_companies">
		<note> Pull new companies from the dataset folders into the system. Runs on init. </note>
		<do action_="api" api_="query">
			<name><%= root_path %>.system_data.companies</name>
			<ops>
				<loop with_="folder" mode_="merge">
				    <outer>
				        <directory folder="<%= root_path %>.dataset_configs"/>
				    </outer>
				    <inner>
				        <base table="{@folder.path}.companies"/>
				    </inner>
				</loop>
				<merge table2="<%= root_path %>.system_data.companies"/>
				<sel value="g_first1(compid;;)"/>
				<sort col="compid"/>
			</ops>
		</do>
		<do><set save_path="<%= root_path %>.system_data.companies" save_title="Companies"/></do>
		<insert block="save"/>
	</block>

	<block name="non_null_constraint">
		<note> Ensure a new compid is non-null. </note>
		<do>
			<if test="{strcmp(@new_compid;'';0)=0}">
				<signal msg="Field 'New compid' is required."/>
			</if>
		</do>
	</block>

	<block name="unique_constraint">
		<note> Ensure a new compid is unique. </note>
		<do base_="<%= root_path %>.system_data.companies" value1_="@not_unique_flag" row1="1" col1="1">
			<willbe name="is_identical" value="compid='{@new_compid}'"/>
			<tabu label="is_unique">
				<tcol source="is_identical" fun="sum" name="not_unique"/>
			</tabu>
		</do>
		<do>
			<if test="{@not_unique_flag}">
				<signal msg="This compid is already present in the database."/>
			</if>
		</do>
	</block>

	<block name="current_compid_exists_constraint">
		<note> Ensure a compid exists when attempting to rename it. </note>
		<do base_="<%= root_path %>.system_data.companies" value1_="@exists_flag" row1="1" col1="1">
			<willbe name="is_identical" value="compid='{@current_compid}'"/>
			<tabu label="exists">
				<tcol source="is_identical" fun="sum" name="not_unique"/>
			</tabu>
		</do>
		<do>
			<if test="{~@exists_flag}">
				<signal msg="Current compid not found in the database."/>
			</if>
		</do>
	</block>

	<block name="insert">
		<note> Manually add a compid into the system. </note>
		<do action_="api" api_="query">
			<name><%= root_path %>.system_data.companies</name>
			<ops>
				<base table="<%= root_path %>.system_data.dummy"/>
				<willbe name="compid" value="'{@new_compid}'"/>
				<colord cols="compid"/>
				<merge table2="<%= root_path %>.system_data.companies" match="order"/>
				<sort col="compid"/>
			</ops>
		</do>
		<do><set save_path="<%= root_path %>.system_data.companies" save_title="Companies"/></do>
		<insert block="save"/>
		<do><set log_table="Companies Transaction Log" audit_path="<%= root_path %>.audit.system_data.companies_transaction_log" action="Add"/></do>
		<insert block="log_transaction"/>
		<do><set table_to_archive="<%= root_path %>.system_data.companies" archive_table_name="Companies Archive" archive_path="<%= root_path %>.audit.system_data.companies_archive"/></do>
		<insert block="archive"/>
	</block>

	<block name="update">
		<note> Rename a compid in the system. </note>
		<do action_="api" api_="query">
			<name><%= root_path %>.system_data.companies</name>
			<ops>
				<base table="<%= root_path %>.system_data.companies"/>
				<willbe name="compid2" value="if(compid='{@current_compid}';'{@new_compid}';compid)"/>
				<colord cols="compid2"/>
				<merge/>
				<willbe name="compid" value="compid2"/>
				<colord cols="compid"/>
			</ops>
		</do>
		<do><set save_path="<%= root_path %>.system_data.companies" save_title="Companies"/></do>
		<insert block="save"/>
		<do><set log_table="Companies Transaction Log" audit_path="<%= root_path %>.audit.system_data.companies_transaction_log" action="Modify"/></do>
		<insert block="log_transaction"/>
		<do><set table_to_archive="<%= root_path %>.system_data.companies" archive_table_name="Companies Archive" archive_path="<%= root_path %>.audit.system_data.companies_archive"/></do>
		<insert block="archive"/>
	</block>

	<block name="cascade_update">
		<note> Propagate an update to other system tables. </note>
		<do action_="api" api_="query">
			<name><%= root_path %>.system_data.access</name>
			<ops>
				<willbe name="compid2" value="if(compid='{@current_compid}';'{@new_compid}';compid)"/>
				<colord hide="compid"/>
				<merge/>
				<willbe name="compid" value="compid2"/>
				<colord cols="compid,dataset,node,ticker_based,access_start,access_end,redaction_start,redaction_end"/>
			</ops>
		</do>
		<do><set save_path="<%= root_path %>.system_data.access" save_title="Access"/></do>
		<insert block="save"/>
	</block>

<note> Access </note>
	<block name="generate_querytree">
		<note> Fetch nodes at successive depths for the querytree widget. </note>
		<base table="<%= root_path %>.system_data.hierarchies"/>
		<layer name="layer_0">
			<sel value="level=0"/>
			<colord cols="key,node,size"/>
		</layer>
		<for i="1" to="{@tree_height}">
			<layer name="layer_{@i}">
				<insert block="get_children" key="{@exp_path.{@i}}"/>
				<colord cols="key,node,size"/>
			</layer>
		</for>
	</block>

	<block name="get_companies">
		<note> Populate Companies dropdownlist. </note>
		<base table="<%= root_path %>.system_data.companies"/>
		<willbe name="quoted" value="splice('\'' compid '\'';'')"/>
		<colord cols="quoted, compid"/>
	</block>

	<note> Grant </note>

	<block name="legal_ticker_insert_constraint" node_list="" company_list="">
		<note> Ensure all companies support ticker-based grants. </note>
		<do base_="<%= root_path %>.system_data.access" value1_="@illegal_insert_flag" row1="1" col1="1">
			<insert block="proposed_grant_table" node_list="{@node_list}" company_list="{@company_list}"/>
			<link table2="<%= root_path %>.system_data.hierarchies" col="dataset,node" expand="1">
				<insert block="path_table" hierarchies_table="<%= root_path %>.system_data.hierarchies"/>
				<colord cols="dataset,node,node_ancestor"/>
			</link>
			<willbe name="key_ancestor" value="if(node_ancestor='all';'none.all';splice(dataset node_ancestor;'.'))"/>
			<willbe name="ancestor_is_key" value="g_position(compid;;;key;key_ancestor)>0"/>
			<tabu label="illegal_insert">
				<tcol fun="hi" source="ancestor_is_key"/>
			</tabu>
		</do>
		<do>
			<if test="{@illegal_insert_flag}">
				<signal msg="Error: It appears that you are trying to perform a ticker-based grant on one or more companies that currently have hierarchy-based access. To continue, please revoke from these companies access to all non-ticker nodes."/>
			</if>
		</do>
	</block>

	<block name="legal_dataset_constraint">
		<do base_="<%= root_path %>.system_data.access" value1_="@legal_dataset_flag" row1="1" col1="1">
			<insert block="proposed_grant_table" node_list="{@node_list}" company_list="{@company_list}"/>

		</do>
	</block>

	<block name="non_empty_lists_check">
		<note> Ensure the user has selected something. </note>
		<do>
			<if test="{csl_len(@node_list)=0 | csl_len(@company_list)=0}">
				<signal msg="Please select at least one node and company first."/>
			</if>
		</do>
	</block>

	<block name="access_difference" node_list="" company_list="">
		<note> Find everything in the cartesian product of companies and nodes not already present in the access table. </note>
		<if test="{csl_len(@node_list)>0 & csl_len(@company_list)>0}">
			<then>
				<base table="<%= root_path %>.system_data.companies"/>
				<sel value="compid={@company_list}"/>
				<willbe name="dummy" value="1"/>
				<link table2="<%= root_path %>.system_data.hierarchies" col="dummy" expand="1">
					<if test="{'{@mode}'='Ticker'}">
						<then>
							<insert block="leaf_table" hierarchies_table="<%= root_path %>.system_data.hierarchies"/>
							<sel value="key={@node_list}"/>
							<colord cols="dataset,leaf"/>
							<sel value="g_first1(dataset,leaf;;)"/>
							<merge/>
							<willbe name="node" value="leaf"/>
						</then>
						<else>
							<sel value="key={@node_list}"/>
						</else>
					</if>
					<willbe name="dummy" value="1"/>
					<colord cols="dataset,node,key,dummy"/>
				</link>
				<colord hide="dummy"/>
				<note> These ifs are necessary because an empty dynamic variable registers as an omission of the 'value' argument in the willbe. </note>
				<if test="{'{@access_start}'=''}">
					<then><willbe name="access_start" value="na"/></then>
					<else><willbe name="access_start" value="{@access_start}"/></else>
				</if>
				<if test="{'{@access_end}'=''}">
					<then><willbe name="access_end" value="na"/></then>
					<else><willbe name="access_end" value="{@access_end}"/></else>
				</if>
				<if test="{'{@redaction_start}'=''}">
					<then><willbe name="redaction_start" value="na"/></then>
					<else><willbe name="redaction_start" value="{@redaction_start}"/></else>
				</if>
				<if test="{'{@redaction_end}'=''}">
					<then><willbe name="redaction_end" value="na"/></then>
					<else><willbe name="redaction_end" value="{@redaction_end}"/></else>
				</if>
				<merge/>
				<link table2="<%= root_path %>.system_data.access" col="compid,dataset,node,access_start,access_end,redaction_start,redaction_end" type="exclude"/>
			</then>
			<else>
				<meta>empty</meta>
				<base table="<%= root_path %>.system_data.access"/>
				<sel value="i_=-1"/>
			</else>
		</if>
	</block>

	<block name="prune">
		<note> Remove from the table all nodes for which an ancestor is present in the table. </note>
		<link table2="<%= root_path %>.system_data.hierarchies" col="dataset,node" expand="1">
			<insert block="path_table" hierarchies_table="<%= root_path %>.system_data.hierarchies"/>
			<colord cols="dataset,node,node_ancestor"/>
		</link>
		<willbe name="key_ancestor" value="if(node_ancestor='all';'none.all';splice(dataset node_ancestor;'.'))"/>
		<willbe name="ancestor_is_key" value="g_position(compid;;;key;key_ancestor)>0"/>
		<sel value="~g_or(compid key;;ancestor_is_key)"/>
		<sel value="g_first1(compid key;;)"/>
		<colord hide="node_ancestor,ancestor_is_key,key,key_ancestor"/>
	</block>

	<block name="proposed_grant_table" node_list="" company_list="">
		<note> Compute the new access table given the selected nodes and companies. </note>
		<insert block="access_difference" node_list="{@node_list}" company_list="{@company_list}"/>
		<merge table2="<%= root_path %>.system_data.access">
			<willbe name="key" value="splice(dataset node;'.')"/>
		</merge>
		<if test="{'{@mode}'='Hierarchy'}">
			<insert block="prune"/>
		</if>
	</block>

	<block name="grant_unchanged" node_list="" company_list="">
		<note> Find everything in the cartesian product of nodes and companies already present in the access table. </note>
		<meta>empty</meta>
		<if test="{csl_len(@node_list)>0 & csl_len(@company_list)>0}">
			<then>
				<insert block="proposed_grant_table" node_list="{@node_list}" company_list="{@company_list}"/>
				<sel value="compid={@company_list}"/>
				<if test="{'{@mode}'='Ticker'}">
					<link table2="<%= root_path %>.system_data.hierarchies" col="dataset,node"/>
					<sel value="size=0"/>
					<colord hide="pre,level,size,post,ancestor_is_node"/>
				</if>
				<sel value="key={@node_list}"/>
			</then>
			<else>
				<base table="<%= root_path %>.system_data.access"/>
				<sel value="i_=-1"/>
			</else>
		</if>
		<insert block="compute_filters" hierarchies_table="<%= root_path %>.system_data.hierarchies"/>
		<link table2="<%= root_path %>.system_data.filters" col="compid,dataset,node,access_start,access_end,redaction_start,redaction_end" type="include"/>
	</block>

	<block name="grant_insertions" node_list="" company_list="">
		<note> Find which nodes would be inserted on a grant operation. </note>
		<meta>empty</meta>
		<if test="{csl_len(@node_list)>0 & csl_len(@company_list)>0}">
			<then>
				<insert block="proposed_grant_table" node_list="{@node_list}" company_list="{@company_list}"/>
				<link table2="<%= root_path %>.system_data.access" col="compid,dataset,node,access_start,access_end,redaction_start,redaction_end" type="exclude"/>
			</then>
			<else>
				<base table="<%= root_path %>.system_data.access"/>
				<sel value="i_=-1"/>
			</else>
		</if>
		<insert block="compute_filters" hierarchies_table="<%= root_path %>.system_data.hierarchies"/>
		<link table2="<%= root_path %>.system_data.filters" col="compid,dataset,node,access_start,access_end,redaction_start,redaction_end" type="exclude"/>
	</block>

	<block name="grant_deletions" node_list="" company_list="">
		<note> Find which nodes would be deleted on a grant operation. </note>
		<meta>empty</meta>
		<if test="{csl_len(@node_list)>0 & csl_len(@company_list)>0}">
			<then>
				<base table="<%= root_path %>.system_data.access"/>
				<link table2="<%= root_path %>.system_data.access" col="compid,dataset,node,access_start,access_end,redaction_start,redaction_end" type="exclude">
					<insert block="proposed_grant_table" node_list="{@node_list}" company_list="{@company_list}"/>
				</link>
			</then>
			<else>
				<base table="<%= root_path %>.system_data.access"/>
				<sel value="i_=-1"/>
			</else>
		</if>
	</block>

	<block name="grant">
		<note> Perform a grant operation. </note>
		<do action_="api" api_="dbupdate">
			<path><%= root_path %>.system_data.access</path>
		</do>
		<do action_="api" api_="query">
			<name><%= root_path %>.system_data.access</name>
			<ops>
				<base table="<%= root_path %>.system_data.access"/>
				<insert block="proposed_grant_table" node_list="{@node_list}" company_list="{@company_list}"/>
			</ops>
		</do>
		<do><set save_path="<%= root_path %>.system_data.access" save_title="Access"/></do>
		<insert block="save"/>
		<do><set log_table="Access Transaction Log" audit_path="<%= root_path %>.audit.system_data.access_transaction_log" action="Grant"/></do>
		<insert block="log_transaction"/>
		<do><set table_to_archive="<%= root_path %>.system_data.access" archive_table_name="Access Archive" archive_path="<%= root_path %>.audit.system_data.access_archive"/></do>
		<insert block="archive"/>
	</block>

	<note> Revoke </note>

	<block name="proposed_revoke_table" node_list="" company_list="">
		<note> Compute the new access table given the selected nodes and companies. </note>
		<base table="<%= root_path %>.system_data.access"/>
		<link table2="<%= root_path %>.system_data.companies" col="compid,dataset,node" type="exclude">
			<sel value="compid={@company_list}"/>
			<willbe name="dummy" value="1"/>
			<link table2="<%= root_path %>.system_data.hierarchies" col="dummy" expand="1" col2="dummy" shift="0">
				<insert block="path_table" hierarchies_table="<%= root_path %>.system_data.hierarchies"/>
				<sel value="key={@node_list}|key_ancestor={@node_list}"/>
				<sel value="g_first1(dataset node;;)"/>
				<willbe name="dummy" value="1"/>
				<colord cols="dataset,node,dummy"/>
			</link>
			<colord hide="dummy"/>
		</link>
	</block>

	<block name="revoke_deletions" node_list="" company_list="">
		<note> Find which nodes would be deleted on a revoke operation. </note>
		<meta>empty</meta>
		<if test="{csl_len(@node_list)>0 & csl_len(@company_list)>0}">
			<then>
				<base table="<%= root_path %>.system_data.access"/>
				<link table2="<%= root_path %>.system_data.access" col="compid,dataset,node" type="exclude">
					<insert block="proposed_revoke_table" node_list="{@node_list}" company_list="{@company_list}"/>
				</link>
			</then>
			<else>
				<base table="<%= root_path %>.system_data.access"/>
				<sel value="i_=-1"/>
			</else>
		</if>
		<insert block="compute_filters" hierarchies_table="<%= root_path %>.system_data.hierarchies"/>
	</block>

	<block name="revoke">
		<note> Perform a revoke operation. </note>
		<do action_="api" api_="dbupdate">
			<path><%= root_path %>.system_data.access</path>
		</do>
		<do action_="api" api_="query">
			<name><%= root_path %>.system_data.access</name>
			<ops>
				<base table="<%= root_path %>.system_data.access"/>
				<insert block="proposed_revoke_table" node_list="{@node_list}" company_list="{@company_list}"/>
			</ops>
		</do>
		<do><set save_path="<%= root_path %>.system_data.access" save_title="Access"/></do>
		<insert block="save"/>
		<do><set log_table="Access Transaction Log" audit_path="<%= root_path %>.audit.system_data.access_transaction_log" action="Revoke"/></do>
		<insert block="log_transaction"/>
		<do><set table_to_archive="<%= root_path %>.system_data.access" archive_table_name="Access Archive" archive_path="<%= root_path %>.audit.system_data.access_archive"/></do>
		<insert block="archive"/>
	</block>

	<note> Misc. </note>

	<block name="view" node_list="" company_list="">
		<note> Show everything if nothing is selected, otherwise show selection. </note>
		<base table="<%= root_path %>.system_data.access"/>
		<willbe name="key" value="splice(dataset node;'.')"/>
		<if test="{strcmp(@company_list;'';0)<>0}">
			<then>
				<if test="{strcmp(@node_list;'';0)<>0}">
					<then>
						<sel value="compid={@company_list}&key={@node_list}"/>
					</then>
					<else>
						<sel value="compid={@company_list}"/>
					</else>
				</if>
			</then>
		</if>
		<colord hide="key"/>
	</block>

	<block name="company_metrics_main">
		<note> The main info dashboard in the summary tab. </note>
		<base table="<%= root_path %>.system_data.companies"/>
	    <note>Prepare table</note>
	    <sel value="compid={@company_list}"/>
	    <willbe name="key" value="{@cm_key}"/>
	    <note>Count total children</note>
	    <link table2="<%= root_path %>.system_data.hierarchies" col="key" col2="parent" cols="dataset,node,total_children_raw" expand="1">
	        <insert block="get_children" key="{{@cm_key}}"/>
	        <willbe name="parent" value="{@cm_key}"/>
	        <link table2="<%= root_path %>.system_data.hierarchies" col="key" col2="key_ancestor" cols="total_children_raw">
	            <insert block="path_table" hierarchies_table="<%= root_path %>.system_data.hierarchies"/>
	            <sel value="level=level_ancestor+1"/>
	            <willbe name="total_children_raw" value="g_cnt(key_ancestor;)"/>
	        </link>
	    </link>
	    <note>Count children to which each company has access</note>
	    <link table2="<%= root_path %>.system_data.hierarchies" col="compid,dataset,node" col2="compid,dataset,node" cols="access_children_raw" expand="1">
	        <insert block="get_children" key="{{@cm_key}}"/>
	        <willbe name="parent" value="{@cm_key}"/>
	        <link table2="<%= root_path %>.system_data.hierarchies" col="key" col2="key_ancestor" cols="compid,access_children_raw">
	            <insert block="path_table" hierarchies_table="<%= root_path %>.system_data.hierarchies"/>
	            <sel value="level=level_ancestor+1"/>
<ignore>
	            <link table2="<%= root_path %>.system_data.access" col="dataset,node" cols="compid" type="select" expand="1">
	                <sel value="compid={@company_list}"/>
	            </link>
	            <willbe name="access_children_raw"   value="g_cnt(compid key_ancestor;)"/>
</ignore>

					<link table2="<%= root_path %>.system_data.access" col="key_ancestor" suffix="_key" col2="key" cols="compid,ind" expand="1" shift="0">
						<willbe name="key" value="splice(dataset node;'.')"/>
						<sel value="compid={@company_list}"/>
						<willbe name="ind" value="1"/>
					</link>
					<link table2="<%= root_path %>.system_data.access" col="dataset,node" suffix="_node" cols="compid,ind" expand="1" col2="dataset,node" shift="0">
						<sel value="compid={@company_list}"/>
						<willbe name="ind" value="1"/>
					</link>
					<sel value="(ind_node=1)|(ind_key=1)"/>
					<willbe name="compid" value="ifnull(compid_key;compid_node)"/>
					<willbe name="access_children_raw" value="g_cnt(compid key_ancestor;)"/>

	        </link>
	    </link>
	    <note>Count total leaves</note>
	    <link table2="<%= root_path %>.system_data.hierarchies" col="dataset,node" cols="total_leaves_raw">
	        <insert block="get_children" key="{{@cm_key}}"/>
	        <willbe name="parent" value="{@cm_key}"/>
	        <link table2="<%= root_path %>.system_data.hierarchies" col="key" cols="total_leaves_raw">
	            <insert block="leaf_table" hierarchies_table="<%= root_path %>.system_data.hierarchies"/>
	            <willbe name="total_leaves_raw" value="g_cnt(dataset node;)"/>
	        </link>
	    </link>
	    <note>Count leaves to which each company has access</note>
	    <link table2="<%= root_path %>.system_data.hierarchies" col="dataset,node" cols="access_leaves_raw">
	        <insert block="get_children" key="{{@cm_key}}"/>
	        <willbe name="parent" value="{@cm_key}"/>
	        <link table2="<%= root_path %>.system_data.hierarchies" col="key" cols="access_leaves_raw">
	            <insert block="leaf_table" hierarchies_table="<%= root_path %>.system_data.hierarchies"/>
	            <link table2="<%= root_path %>.system_data.hierarchies" col="key" cols="access_leaves_raw">
	                <insert block="leaf_table" hierarchies_table="<%= root_path %>.system_data.hierarchies"/>
	                <link table2="<%= root_path %>.system_data.filters" col="dataset,leaf" col2="dataset,node" cols="compid" type="select" expand="1">
	                    <sel value="compid={@company_list}"/>
	                </link>
	                <willbe name="access_leaves_raw" value="g_cnt(compid dataset node;)"/>
	            </link>
	        </link>
	    </link>
	    <note>Cleanup</note>
	    <willbe name="total_children" label="Total Children" value="if(total_children_raw=na;0;total_children_raw)"/>
	    <willbe name="access_children" label="Children Company can Access" value="if(access_children_raw=na;0;access_children_raw)"/>
		<willbe name="total_leaves" label="Total Identifiers" value="if(total_leaves_raw=na;0;total_leaves_raw)"/>
		<willbe name="access_leaves" label="Identifiers Company can Access" value="if(access_leaves_raw=na;0;access_leaves_raw)"/>
	    <colord cols="compid,dataset,node,access_leaves,total_leaves,access_children,total_children"/>
	</block>

	<block name="company_metrics_access_leaves">
		<note> Auxiliary table in the summary tab. Shows leaves to which company has access. </note>
		<base table="<%= root_path %>.system_data.hierarchies"/>
		<insert block="leaf_table" hierarchies_table="<%= root_path %>.system_data.hierarchies"/>
		<if test="{{@cm_key}='none.all'}">
			<then>
				<note> Get all leaves </note>
				<sel value="g_first1(dataset leaf;;)"/>
			</then>
			<else>
				<note> Get leaves for the selected subtree </note>
				<sel value="key={@cm_key}"/>
			</else>
		</if>
	    <link table2="<%= root_path %>.system_data.filters" col="dataset,leaf" col2="dataset,node" type="include">
	        <sel value="compid={@company_list}"/>
	    </link>
		<willbe name="identifier" value="leaf"/>
		<colord cols="dataset,identifier"/>
		<sort col="dataset" dir="up"/>
	</block>

	<block name="company_metrics_no_access_leaves">
		<note> Auxiliary table in the summary tab. Shows leaves to which the company does not have access. </note>
		<base table="<%= root_path %>.system_data.hierarchies"/>
		<insert block="leaf_table" hierarchies_table="<%= root_path %>.system_data.hierarchies"/>
		<if test="{{@cm_key}='none.all'}">
			<then>
				<note> Get all leaves </note>
				<sel value="g_first1(dataset leaf;;)"/>
			</then>
			<else>
				<note> Get leaves for the selected subtree </note>
				<sel value="key={@cm_key}"/>
			</else>
		</if>
	    <link table2="<%= root_path %>.system_data.filters" col="dataset,leaf" col2="dataset,node" type="exclude">
	        <sel value="compid={@company_list}"/>
	    </link>
		<willbe name="identifier" value="leaf"/>
		<colord cols="dataset,identifier"/>
		<sort col="dataset" dir="up"/>
	</block>

<note> Hierarchies </note>

	<note> Constraints </note>
	<block name="dataset_selected_constraint">
		<note> Ensure a dataset has been selected in the dropdown. </note>
		<do>
			<if test="{strcmp(@dataset;'';0)=0}">
				<signal msg="Please select a dataset first."/>
			</if>
		</do>
	</block>

	<block name="leaf_node_constraint">
		<note> Ensure a node is a leaf on hierarchy modify. </note>
		<do base_="<%= root_path %>.system_data.hierarchies" value1_="@is_leaf_flag" row1="1" col1="1">
			<insert block="leaf_table" hierarchies_table="<%= root_path %>.system_data.hierarchies"/>
			<willbe name="is_identical" value="dataset='{@dataset}'&leaf='{@current_node}'"/>
			<tabu label="exists">
				<tcol source="is_identical" fun="sum" name="not_unique"/>
			</tabu>
		</do>
		<do>
			<if test="{@is_leaf_flag>0}">
				<signal msg="Illegal operation: Current node either isn't present in the database, or is a leaf node."/>
			</if>
		</do>
	</block>

	<block name="non_null_node_constraint">
		<note> Ensure node is non null on hierarchy modify. </note>
		<do>
			<if test="{strcmp(@new_node;'';0)=0}">
				<signal msg="Field 'New node' is required."/>
			</if>
		</do>
	</block>

	<block name="unique_node_constraint">
		<note> Ensure node is unique on hierarchy modify. </note>
		<do base_="<%= root_path %>.system_data.hierarchies" value1_="@not_unique_flag" row1="1" col1="1">
			<willbe name="is_identical" value="dataset='{@dataset}'&node='{@new_node}'"/>
			<tabu label="is_unique">
				<tcol source="is_identical" fun="sum" name="not_unique"/>
			</tabu>
		</do>
		<do>
			<if test="{@not_unique_flag}">
				<signal msg="This node is already present in the database."/>
			</if>
		</do>
	</block>

	<block name="unique_leaves_constraint">
		<note> Ensure leaves have unique names on hierarchy update. </note>
		<do base_="<%= root_path %>.system_data.temp.new_raw_hierarchy" value1_="@not_unique_leaves_flag" row1="1" col1="1">
		<willbe name="leaves" value="r_last(;)"/>
		<willbe name="num_unique_leaves" value="g_ucnt(;;leaves)"/>
		<willbe name="num_leaves" value="n_"/>
		<willbe name="not_unique_leaves" value="num_unique_leaves<>num_leaves"/>
		<colord cols="not_unique_leaves"/>
		</do>
		<do>
			<if test="{@not_unique_leaves_flag}">
				<signal msg="The leaves are not unique."/>
			</if>
		</do>
 	</block>

	<note> Tree conversion </note>
	<block name="left_align" nrow="" ncol="" col_list="root" row_list="m0_new">
		<note> Left-align the hierarchy. </note>
		<set col_list="{splice('{@col_list}' 'd0';',')}"/>
		<for i="1" to="{@ncol}">
			<set col_list="{splice('{@col_list}' 'd{@i}';',')}"/>
		</for>
		<willbe name="d0" value="'{@dataset}'"/>

		<set nums="0 1 2 3 4 5 6 7 8 9"/>
		<set letters="'a','b','c','d','e','f','g','h','i','j'"/>
		<for i="0" to="{@ncol-1}">
			<willbe name="d{@i + 1}" value="{decode({@i};{@nums};{@letters})}"/>
		</for>
		<colord cols="{@col_list}"/>
	</block>

	<block name="convert" ncol="" col_list="root" size_list="root_size" called_by_sched="0">
		<note> Convert from path format to columnar, pre-post-depth-size format. </note>
		<note> Preprocessing - get tree depth, create column list and root node </note>
		<if test="{~@called_by_sched}">
			<set ncol="{max({tabledata('<%= root_path %>.system_data.temp.new_raw_hierarchy';'ncols';)};{tabledata('<%= root_path %>.system_data.raw_hierarchies';'ncols';)})}"/>
		</if>
		<set col_list="{splice('{@col_list}' 'd0';',')}"/>
		<set size_list="{splice('{@size_list}' 'd0_size';',')}"/>
		<for i="1" to="{@ncol-1}">
			<set col_list="{splice('{@col_list}' 'd{@i}';',')}"/>
			<set size_list="{splice('{@size_list}' 'd{@i}_size';',')}"/>
		</for>
		<insert block="compute_unlaunched_against_current"/>
		<if test="{@has_tickers}">
			<insert block="compute_unlaunched_against_new" col_list="{@col_list}"/>
		</if>
		<willbe name="root" value="'all'"/>
		<sort cols="{@col_list}"/>

		<note> Get size of each subtree at each depth </note>
		<willbe name="d{@ncol - 1}_size" value="0"/>
		<willbe name="d{@ncol - 1}_first" value="g_first1(d{@ncol - 1} d0;;)"/>
		<for i="{@ncol - 2}" to="0" by="-1">
			<willbe name="d{@i}_size" value="g_ucnt(d{@i} d0;;d{@i + 1}) + g_sum(d{@i} d0; d{@i + 1}_first; d{@i + 1}_size)"/>
			<willbe name="d{@i}_first" value="g_first1(d{@i} d0;;)"/>
		</for>
    	<willbe name="root_size" value="g_ucnt(root;;d0) + g_sum(root; d0_first; d0_size)"/>
    	<willbe name="root_first" value="g_first1(root;;)"/>

		<note> Expand by height of each leaf, preserving computed information </note>
		<willbe name="spliced_nodes" value="splice({@col_list};',')"/>
		<willbe name="spliced_sizes" value="splice({@size_list};',')"/>

		<willbe name="height" value="csl_len(strtrim(strsort(spliced_nodes;',';0;1); ','; 0; 1))"/>
		<sel value="height" expand="1"/>
		<willbe name="factor" value="ii_(1)"/>

		<note> Get diagonal of expansion of each row </note>
		<willbe name="node" value="strpick(spliced_nodes;',';factor)"/>
		<willbe name="size" value="int(strpick(spliced_sizes;',';factor))"/>

		<note> Distil into pre-order </note>
		<sel value="g_first1(node d0;;)"/>
		<sel value="node<>'all'|g_first1(node;;)"/>

		<note> Compute pre, level, and post </note>
		<willbe name="pre" value="i_(0)"/>
		<willbe name="level" value="factor-1"/>
		<willbe name="neg_level" value="-level"/>
		<willbe name="post" value="int(r_sum(pre size neg_level;))"/>

		<note> Display result in standard format </note>
		<willbe name="dataset" value="if(node='all';'none';d0)"/>
		<willbe name="key" value="splice(dataset node;'.')"/>
		<colord cols="dataset,node,key,pre,level,size,post"/>
	</block>

	<note> Tree queries </note>
	<block name="get_height">
		<note> Find height of tree. </note>
		<base table="<%= root_path %>.system_data.hierarchies"/>
		<tabu label="tree_height">
			<tcol fun="hi" source="level"/>
		</tabu>
	</block>

	<block name="get_children" key="">
		<note> Find the children of a node. </note>
		<willbe name="sel" value="if(key='{@key}';1;0)"/>
		<willbe name="pre_val" value="g_sum(;sel;pre)"/>
		<willbe name="post_val" value="g_sum(;sel;post)"/>
		<willbe name="level_val" value="g_sum(;sel;level)"/>
		<sel value="pre > pre_val & post < post_val & level = level_val + 1"/>
	</block>

	<block name="get_parent" key="">
		<note> Find the parent of a node. </note>
		<note> Base case: Define root as its own parent </note>
		<if test="{strcmp({@key};'none.all';0)=0}">
			<then>
				<sel value="key='none.all'"/>
			</then>
			<else>
				<willbe name="sel" value="if(key={@key};1;0)"/>
				<willbe name="pre_val" value="g_sum(;sel;pre)"/>
				<willbe name="post_val" value="g_sum(;sel;post)"/>
				<willbe name="level_val" value="g_sum(;sel;level)"/>
				<sel value="pre < pre_val & post > post_val & level = level_val - 1"/>
			</else>
		</if>
	</block>

	<block name="path_table" hierarchies_table="">
		<note> Compute the path table. </note>
		<sel value="if(level=0;1;level)" expand="1"/>
		<willbe name="level_ancestor" value="ii_(0)"/>
		<link table2="{@hierarchies_table}" col="level_ancestor" col2="level" suffix="_ancestor" expand="1"/>
		<sel value="pre_ancestor<pre&post_ancestor>post"/>
	</block>

	<block name="leaf_table" hierarchies_table="">
		<note> Compute the leaf table. </note>
		<insert block="path_table" hierarchies_table="{@hierarchies_table}"/>
		<sel value="size=0"/>
		<colord cols="dataset,node_ancestor,node"/>
		<note> Set leaves as their own descendants. This ensures any leaves in access make it into filters. </note>
		<merge table2="{@hierarchies_table}">
			<sel value="size=0"/>
			<willbe name="node_ancestor" value="node"/>
		</merge>
		<note> Cleanup - make names more accessible. </note>
		<willbe name="leaf" value="node"/>
		<colord hide="node"/>
		<merge/>
		<willbe name="node" value="node_ancestor"/>
		<willbe name="key" value="splice(dataset node;'.')"/>
		<colord cols="dataset,node,key,leaf"/>
		<sort col="node_ancestor" dir="up"/>
	</block>

	<note> Update hierarchy </note>
	<block name="save_new_raw_hierarchy">
		<note> Saves new raw hierarchy into temp folder. </note>
		<do base_="{@temp_path}" action_="api" api_="query">
			<name>{@temp_path}</name>
			<base table="{@temp_path}"/>
		</do>
		<do>
			<set save_path="<%= root_path %>.system_data.temp.new_raw_hierarchy" save_title="New Raw Hierarchy"/>
		</do>
		<insert block="save"/>


		<note> Check whether leaves are unique </note>
		<insert block="unique_leaves_constraint"/>


		<note>Write metadata to table</note>
		<do action_="api" api_="gettab" value_="@gettab_result">
			<name>{@save_path}</name>
		</do>
		<do>
			<set id="{@gettab_result..tab['id']._or_empty}"/>
		</do>
		<do action_="api" api_="puttab">
			<tab id="{@id}" title="{@save_title}" users="{@username_}"/>
		</do>
		<do base_="<%= root_path %>.system_data.temp.new_raw_hierarchy" action_="api" api_="query">
			<name><%= root_path %>.system_data.temp.new_raw_hierarchy</name>
			<base table="<%= root_path %>.system_data.temp.new_raw_hierarchy"/>
		</do>
		<do base_="<%= root_path %>.system_data.raw_hierarchies" action_="api" api_="query">
			<name><%= root_path %>.system_data.raw_hierarchies</name>
			<base table="<%= root_path %>.system_data.raw_hierarchies"/>
		</do>
		<note> Left-align the hierarchy </note>
		<do base_="<%= root_path %>.system_data.temp.new_raw_hierarchy" action_="api" api_="query">
			<name><%= root_path %>.system_data.temp.new_raw_hierarchy</name>
			<ops>
				<letseq nsegs="{tabledata('<%= root_path %>.system_data.temp.new_raw_hierarchy';'nsegs';)}" nrow="{int(tabledata('<%= root_path %>.system_data.temp.new_raw_hierarchy';'dataloc_to';@~nsegs-1))+1}" ncol="{tabledata('<%= root_path %>.system_data.temp.new_raw_hierarchy';'ncols';)}">
					<insert block="left_align" nrow="{@nrow}" ncol="{@ncol}"/>
				</letseq>
			</ops>
		</do>
		<do>
			<set save_path="<%= root_path %>.system_data.temp.new_raw_hierarchy" save_title="New Raw Hierarchy"/>
		</do>
		<do><insert block="save"/></do>
	</block>

	<block name="compute_unlaunched_against_current">
		<note> Infer unlaunched from each dataset folder and, last of all, the new dataset hierarchy </note>
		<merge table2="default.lonely" match="pad">
			<loop with_="tickers_table"  mode_="merge">
				<outer>
					<directory folder="<%= root_path %>.dataset_configs" depth="2"/>
					<sel value="title='Tickers'"/>
					<willbe name="dataset" value="csl_pick(strsubst(path;'.';0;',');-2)"/>
					<willbe name="raw_hierarchy_path" value="splice('<%= root_path %>.dataset_configs' dataset 'raw_hierarchy';'.')"/>
					<colord cols="path,dataset,raw_hierarchy_path"/>
				</outer>
				<inner>
					<merge table2="{@tickers_table.path}" match="pad">
					    <link table2="{@tickers_table.raw_hierarchy_path}" col="ticker" type="exclude">
							<loop with_="row" mode_="merge">
								<outer>
									<base table="{@tickers_table.raw_hierarchy_path}"/>
								</outer>
								<inner>
									<note> Turn values for the row into a list of strings, then put them into a 1 column table </note>
									<set listval=""/>
									<foreach var="{pkg_names(@row)}">
										<set listval="{splice('{@listval}' @row.{@var};',')}"/>
									</foreach>
									<set listval="{strdrop(@listval;'';1)}"/>
									<set listval="{strsubst('{@listval}';',';0;'\',\'')}"/>
									<set listval="{splice('\'' @listval '\'';'')}"/>
									<table depth="{lst_len(pkg_names(@row))}"/>
									<willbe name="m0" value="{@listval}"/>
								</inner>
							</loop>
							<willbe name="ticker" value="string(m0)"/>
							<colord hide="m0"/>
							<sel value="g_first1(ticker;;)&ticker<>na"/>
					    </link>
					    <willbe name="d0" value="'{@tickers_table.dataset}'"/>
					    <willbe name="d1" value="'unlaunched'"/>
					    <willbe name="d2" value="ticker"/>
					    <colord hide="ticker"/>
					</merge>
				</inner>
			</loop>
		</merge>
		<colord hide="A"/>
	</block>

	<block name="compute_unlaunched_against_new">
		<note> Handle unlaunched tickers in a hierarchy update operation. </note>
		<merge table2="<%= root_path %>.dataset_configs.{@dataset}.tickers" match="pad">
		    <link table2="<%= root_path %>.system_data.temp.new_raw_hierarchy" col="ticker" type="exclude">
				<loop with_="row" mode_="merge">
					<outer>
						<base table="<%= root_path %>.system_data.temp.new_raw_hierarchy"/>
					</outer>
					<inner>
						<note> Turn values for the row into a list of strings, then put them into a 1 column table </note>
						<set listval=""/>
						<foreach var="{pkg_names(@row)}">
							<set listval="{splice('{@listval}' @row.{@var};',')}"/>
						</foreach>
						<set listval="{strdrop(@listval;'';1)}"/>
						<set listval="{strsubst('{@listval}';',';0;'\',\'')}"/>
						<set listval="{splice('\'' @listval '\'';'')}"/>
						<table depth="{lst_len(pkg_names(@row))}"/>
						<willbe name="m0" value="{@listval}"/>
					</inner>
				</loop>
				<willbe name="ticker" value="string(m0)"/>
				<colord hide="m0"/>
				<sel value="g_first1(ticker;;)&ticker<>na"/>
		    </link>
		    <willbe name="d0" value="'{@dataset}'"/>
		    <willbe name="d1" value="'unlaunched'"/>
		    <willbe name="d2" value="ticker"/>
		    <colord hide="ticker"/>
		</merge>
		<sel value="g_first1({csl_drop(@col_list;1)};;)"/>
	</block>

	<block name="has_tickers">
		<do value_="has_tickers" row_="1" col_="1">
			<note> Check if the dataset being modified has a Tickers table </note>
			<directory folder="{@dataset_folder}"/>
			<willbe name="sel" value="title='Tickers'"/>
			<willbe name="has_tickers" value="g_sum(;;sel)"/>
			<colord cols="has_tickers"/>
		</do>
	</block>

	<block name="save_proposed_raw_hierarchies_table">
		<note> Save new raw hierarchies into temp folder. </note>
		<do base_="<%= root_path %>.system_data.temp.new_raw_hierarchy" action_="api" api_="query">
			<name><%= root_path %>.system_data.temp.new_raw_hierarchy</name>
			<ops>
				<base table="<%= root_path %>.system_data.raw_hierarchies"/>
				<meta>empty</meta>
				<sel value="d0<>'{@dataset}'"/>
				<merge table2="<%= root_path %>.system_data.temp.new_raw_hierarchy" match="pad"/>
			</ops>
		</do>
		<do>
			<set save_path="<%= root_path %>.system_data.temp.new_raw_hierarchies" save_title="New Raw Hierarchies"/>
		</do>
		<do><insert block="save"/></do>
	</block>

	<block name="save_proposed_hierarchies_table">
		<note> Save new hierarchies table into temp folder. </note>
		<do base_="<%= root_path %>.system_data.temp.new_raw_hierarchies" action_="api" api_="query">
			<name><%= root_path %>.system_data.temp.new_raw_hierarchies</name>
			<ops>
				<import path="<%= root_path %>.model"/>
				<loop with_="open_tab">
					<outer>
						<base table="<%= root_path %>.system_data.temp.new_raw_hierarchies"/>
						<sel value="i_()=1"/>
					</outer>
					<inner>
						<base table="<%= root_path %>.system_data.temp.new_raw_hierarchies"/>
						<set tab="<%= root_path %>.system_data.temp.new_raw_hierarchies"/>
						<letseq nsegs="{tabledata(@tab;'nsegs';)}" nrow="{int(tabledata(@tab;'dataloc_to';@~nsegs-1))+1}" ncol="{tabledata(@tab;'ncols';)}">
							<insert block="convert" called_by_sched="1" nrow="{@nrow}" ncol="{@ncol}" has_tickers="0"/>
						</letseq>
					</inner>
				</loop>
			</ops>
		</do>
		<do>
			<set save_path="<%= root_path %>.system_data.temp.new_hierarchies" save_title="New Hierarchies"/>
		</do>
		<do><insert block="save"/></do>
	</block>

	<block name="hierarchy_insertions" nrow="" dataset="">
		<note> Compute additions to dataset hierarchy. </note>
		<meta>empty</meta>
		<base table="<%= root_path %>.system_data.temp.new_hierarchies"/>
		<colord cols="dataset,node"/>
		<link table2="<%= root_path %>.system_data.hierarchies" col="dataset,node" type="exclude"/>
	</block>

	<block name="hierarchy_deletions" nrow="" dataset="">
		<note> Compute deletions from dataset hierarchy. </note>
		<meta>empty</meta>
		<base table="<%= root_path %>.system_data.hierarchies"/>
		<sel value="dataset='{@dataset}'"/>
		<link table2="<%= root_path %>.system_data.temp.new_hierarchies" col="dataset,node" type="exclude"/>
		<colord cols="dataset,node"/>
	</block>

	<block name="filters_cascade_summary">
		<note> Compute impact on filters table. </note>
		<note> Produce new filters table & merge with old filters table </note>
		<meta>empty</meta>
		<base table="<%= root_path %>.system_data.access"/>
		<link table2="<%= root_path %>.system_data.temp.new_hierarchies" col="dataset,node" type="include"/>
		<insert block="compute_filters" hierarchies_table="<%= root_path %>.system_data.temp.new_hierarchies"/>
		<willbe name="new_filter" value="1"/>
		<merge table2="<%= root_path %>.system_data.filters">
		  <willbe name="new_filter" value="0"/>
		</merge>

		<note> Helper columns </note>
		<willbe name="old_filter" value="~new_filter"/>
		<willbe name="first_compid" value="g_first1(compid new_filter;;)"/>
		<willbe name="num_tickers" value="g_cnt(compid new_filter;)"/>
		<willbe name="most_tickers" value="g_hi(compid;;num_tickers)"/>
		<willbe name="least_tickers" value="g_lo(compid;;num_tickers)"/>

		<note> Count total companies </note>
		<willbe name="num_total" value="g_sum(;old_filter;first_compid)"/>

		<note> Count companies with access to more tickers </note>
		<willbe name="has_more" value="num_tickers>least_tickers&first_compid"/>
		<willbe name="num_more" value="g_sum(;new_filter;has_more)"/>

		<note> Count companies with access to fewer tickers </note>
		<willbe name="has_less" value="num_tickers<most_tickers&first_compid"/>
		<willbe name="num_less" value="g_sum(;new_filter;has_less)"/>

		<note> Count companies who no longer have access to any nodes </note>
		<willbe name="has_none" value="(~g_or(compid;;new_filter))&first_compid"/>
		<willbe name="num_none" value="g_sum(;old_filter;has_none)"/>

		<note> Count companies with access to same number of tickers but the set is different </note>
		<willbe name="has_same" value="least_tickers=most_tickers&first_compid"/>

		<willbe name="key" value="splice(dataset node;'.')"/>
		<willbe name="ticker_set" value="g_uval(compid new_filter;;key;','; 2147483646)"/>
		<willbe name="different_set" value="g_ucnt(compid;;ticker_set)>1"/>

		<willbe name="has_same_but_different" value="has_same&different_set"/>
		<willbe name="num_same_but_different" value="g_sum(;new_filter;has_same_but_different)"/>

		<note> Count total companies which have changed </note>
		<willbe name="num_changed" value="num_more+num_less+num_none+num_same_but_different"/>

		<note> Cleanup </note>
		<colord cols="num_total,num_more,num_less,num_none,num_same_but_different,num_changed"/>
		<sel value="i_=1"/>
	</block>

	<block name="access_cascade_deletions" nrow="" dataset="">
		<note> Compute impact on access table. </note>
		<meta>empty</meta>
		<base table="<%= root_path %>.system_data.access"/>
		<link table2="<%= root_path %>.system_data.temp.new_hierarchies" col="dataset,node" type="include">
			<insert block="hierarchy_deletions" nrow="{@nrow}" new_hierarchy="{@new_hierarchy}" dataset="{@dataset}"/>
		</link>
	</block>

	<block name="filters_cascade_insertions">
		<note> Compute insertions to filter. </note>
		<meta>empty</meta>
		<base table="<%= root_path %>.system_data.access"/>
		<link table2="<%= root_path %>.system_data.temp.new_hierarchies" col="dataset,node" type="include"/>
		<insert block="compute_filters" hierarchies_table="<%= root_path %>.system_data.temp.new_hierarchies"/>
		<link table2="<%= root_path %>.system_data.filters" col="compid,dataset,node" type="exclude"/>
	</block>

	<block name="replace_raw_hierarchy">
		<note> Replace raw hierarchy with the new one from the temp folder. </note>
		<do base_="<%= root_path %>.system_data.temp.new_raw_hierarchy" action_="api" api_="query">
			<name><%= root_path %>.system_data.temp.new_raw_hierarchy</name>
			<ops>
				<base table="<%= root_path %>.system_data.temp.new_raw_hierarchy"/>
			</ops>
		</do>
		<do>
			<set save_path="{@dataset_folder}.raw_hierarchy" save_title="Raw Hierarchy"/>
		</do>
		<do><insert block="save"/></do>
		<do><set log_table="{@dataset} Transaction Log" audit_path="<%= root_path %>.audit.dataset_configs.{@dataset}_transaction_log" action="Update"/></do>
		<insert block="log_transaction"/>
		<do><set table_to_archive="{@dataset_folder}.raw_hierarchy" archive_table_name="{@dataset} Archive" archive_path="<%= root_path %>.audit.dataset_configs.{@dataset}_archive"/></do>
		<insert block="archive"/>
	</block>

	<block name="replace_raw_hierarchies">
		<note> Replace raw hierarchies with the new one from the temp folder. </note>
		<do base_="<%= root_path %>.system_data.temp.new_raw_hierarchy" action_="api" api_="query">
			<name><%= root_path %>.system_data.temp.new_raw_hierarchy</name>
			<base table="<%= root_path %>.system_data.temp.new_raw_hierarchy"/>
		</do>
		<do base_="<%= root_path %>.system_data.temp.new_raw_hierarchy" action_="api" api_="query">
			<name><%= root_path %>.system_data.temp.new_raw_hierarchy</name>
			<ops>
				<base table="<%= root_path %>.system_data.raw_hierarchies"/>
				<meta>empty</meta>
				<sel value="d0<>'{@dataset}'"/>
				<merge table2="<%= root_path %>.system_data.temp.new_raw_hierarchy" match="pad"/>
			</ops>
		</do>
		<do>
			<set save_path="<%= root_path %>.system_data.raw_hierarchies" save_title="Raw Hierarchies"/>
		</do>
		<do><insert block="save"/></do>
	</block>

	<block name="replace_hierarchies">
		<note> Replace hierarchies with the new one from the temp folder. </note>
		<do base_="<%= root_path %>.system_data.temp.new_hierarchies" action_="api" api_="query">
			<name><%= root_path %>.system_data.temp.new_hierarchies</name>
			<ops>
				<base table="<%= root_path %>.system_data.temp.new_hierarchies"/>
			</ops>
		</do>
		<do>
			<set save_path="<%= root_path %>.system_data.hierarchies" save_title="Hierarchies"/>
		</do>
		<do><insert block="save"/></do>
		<do><set log_table="Hierarchies Transaction Log" audit_path="<%= root_path %>.audit.system_data.hierarchies_transaction_log" action="Update"/></do>
		<insert block="log_transaction"/>
		<do><set table_to_archive="<%= root_path %>.system_data.hierarchies" archive_table_name="Hierarchies Archive" archive_path="<%= root_path %>.audit.system_data.hierarchies_archive"/></do>
		<insert block="archive"/>
	</block>

	<block name="replace_access_table">
		<note> Replace access table. </note>
		<do base_="<%= root_path %>.system_data.access" action_="api" api_="query">
			<name><%= root_path %>.system_data.access</name>
			<ops>
				<base table="<%= root_path %>.system_data.access"/>
				<meta>empty</meta>
				<link table2="<%= root_path %>.system_data.access" col="dataset,node" type="exclude">
					<insert block="access_cascade_deletions"/>
				</link>
			</ops>
		</do>
		<do>
			<set save_path="<%= root_path %>.system_data.access" save_title="Access"/>
		</do>
		<do><insert block="save"/></do>
	</block>

	<block name="replace_filters_table">
		<note> Replace filters table. </note>
		<do base_="<%= root_path %>.system_data.access" action_="api" api_="query">
			<name><%= root_path %>.system_data.access</name>
			<ops>
				<meta>empty</meta>
				<base table="<%= root_path %>.system_data.access"/>
				<link table2="<%= root_path %>.system_data.hierarchies" col="dataset,node" type="include"/>
				<insert block="compute_filters" hierarchies_table="<%= root_path %>.system_data.hierarchies"/>
			</ops>
		</do>
		<do>
			<set save_path="<%= root_path %>.system_data.filters" save_title="Filters"/>
		</do>
		<do><insert block="save"/></do>
	</block>

	<block name="scheduled_unlaunched_ticker_retrieval">
		<note> Runs nightly. </note>
		<loop with_="open_tab">
			<outer>
				<base table="<%= root_path %>.system_data.raw_hierarchies"/>
				<sel value="i_()=1"/>
			</outer>
			<inner>
				<base table="<%= root_path %>.system_data.raw_hierarchies"/>
				<set tab="<%= root_path %>.system_data.raw_hierarchies"/>
				<letseq nsegs="{tabledata(@tab;'nsegs';)}" nrow="{int(tabledata(@tab;'dataloc_to';@~nsegs-1))+1}" ncol="{tabledata(@tab;'ncols';)}">
				<insert block="convert" called_by_sched="1" nrow="{@nrow}" ncol="{@ncol}" has_tickers="0"/>
				</letseq>
				<materialize path="<%= root_path %>.system_data.hierarchies" replace="1" title="Hierarchies"/>
			</inner>
		</loop>
	</block>

	<note> Modify node </note>
	<block name="check_each_column" col_list="d0" new_col_list="d0_new" table="">
		<note>  </note>
		<set ncol="{tabledata('{@table}';'ncols';)}"/>
		<for i="1" to="{@ncol-1}">
			<set col_list="{splice('{@col_list}' 'd{@i}';',')}"/>
			<set new_col_list="{splice('{@new_col_list}' 'd{@i}_new';',')}"/>
		</for>
		<foreach col="{@col_list}">
			<willbe name="{@col}_new" value="if({@col}='{@current_node}'&d0='{@dataset}';'{@new_node}';{@col})"/>
		</foreach>
		<colord cols="{@new_col_list}"/>
		<merge/>
		<foreach new_col="{@new_col_list}" tally="i">
			<willbe name="d{@i-1}" value="{@new_col}"/>
		</foreach>
		<colord cols="{@col_list}"/>
		<merge/>
	</block>

	<block name="modify_raw_hierarchy">
		<note> Modify the raw hierarchy </note>
		<note> The first query just opens the table, a prerequisite for using tabledata </note>
		<do base_="{@dataset_folder}.raw_hierarchy" action_="api" api_="query">
			<name>{@dataset_folder}.raw_hierarchy</name>
			<ops>
				<base table="{@dataset_folder}.raw_hierarchy"/>
			</ops>
		</do>
		<do base_="{@dataset_folder}.raw_hierarchy" action_="api" api_="query">
			<name>{@dataset_folder}.raw_hierarchy</name>
			<ops>
				<base table="{@dataset_folder}.raw_hierarchy"/>
				<insert block="check_each_column" table="{@dataset_folder}.raw_hierarchy"/>
			</ops>
		</do>
		<do>
			<set save_path="{@dataset_folder}.raw_hierarchy" save_title="Raw Hierarchy"/>
		</do>
		<do><insert block="save"/></do>
		<do><set log_table="{@dataset} Transaction Log" audit_path="<%= root_path %>.audit.dataset_configs.{@dataset}_transaction_log" action="Modify"/></do>
		<insert block="log_transaction"/>
		<do><set table_to_archive="{@dataset_folder}.raw_hierarchy" archive_table_name="{@dataset} Archive" archive_path="<%= root_path %>.audit.dataset_configs.{@dataset}_archive"/></do>
		<insert block="archive"/>
	</block>

	<block name="modify_raw_hierarchies">
		<note> Modify the raw hierarchies </note>
		<note> The first query just opens the table, a prerequisite for using tabledata </note>
		<do base_="<%= root_path %>.system_data.raw_hierarchies" action_="api" api_="query">
			<name><%= root_path %>.system_data.raw_hierarchies</name>
			<ops>
				<base table="<%= root_path %>.system_data.raw_hierarchies"/>
			</ops>
		</do>
		<do base_="<%= root_path %>.system_data.raw_hierarchies" action_="api" api_="query">
			<name><%= root_path %>.system_data.raw_hierarchies</name>
			<ops>
				<base table="<%= root_path %>.system_data.raw_hierarchies"/>
				<insert block="check_each_column" table="<%= root_path %>.system_data.raw_hierarchies"/>
			</ops>
		</do>
		<do>
			<set save_path="<%= root_path %>.system_data.raw_hierarchies" save_title="Raw Hierarchies"/>
		</do>
		<do><insert block="save"/></do>
	</block>

	<block name="modify_hierarchies">
		<note> Modify hierarchies </note>
		<do base_="<%= root_path %>.system_data.hierarchies" action_="api" api_="query">
			<name><%= root_path %>.system_data.hierarchies</name>
			<ops>
				<base table="<%= root_path %>.system_data.hierarchies"/>
				<willbe name="node_new" value="if(node='{@current_node}'&dataset='{@dataset}';'{@new_node}';node)"/>
				<colord hide="node,key"/>
				<merge/>
				<willbe name="node" value="node_new"/>
				<willbe name="key" value="splice(dataset node;'.')"/>
				<colord cols="dataset,node,key,pre,level,size,post"/>
				<merge/>
			</ops>
		</do>
		<do>
			<set save_path="<%= root_path %>.system_data.hierarchies" save_title="Hierarchies"/>
		</do>
		<do><insert block="save"/></do>
		<do><set log_table="Hierarchies Transaction Log" audit_path="<%= root_path %>.audit.system_data.hierarchies_transaction_log" action="Modify"/></do>
		<insert block="log_transaction"/>
		<do><set table_to_archive="<%= root_path %>.system_data.hierarchies" archive_table_name="Hierarchies Archive" archive_path="<%= root_path %>.audit.system_data.hierarchies_archive"/></do>
		<insert block="archive"/>
	</block>

	<block name="modify_access">
		<note> Modify access </note>
		<do base_="<%= root_path %>.system_data.access" action_="api" api_="query">
			<name><%= root_path %>.system_data.access</name>
			<ops>
				<base table="<%= root_path %>.system_data.access"/>
				<willbe name="node_new" value="if(node='{@current_node}'&dataset='{@dataset}';'{@new_node}';node)"/>
				<colord hide="node"/>
				<merge/>
				<willbe name="node" value="node_new"/>
				<colord cols="compid,dataset,node,access_start,access_end,redaction_start,redaction_end"/>
				<merge/>
			</ops>
		</do>
		<do>
			<set save_path="<%= root_path %>.system_data.access" save_title="Access"/>
		</do>
		<do><insert block="save"/></do>
	</block>

	<block name="modify_filters">
		<note> Modify filters </note>
		<do base_="<%= root_path %>.system_data.filters" action_="api" api_="query">
			<name><%= root_path %>.system_data.filters</name>
			<ops>
				<base table="<%= root_path %>.system_data.filters"/>
				<willbe name="node_new" value="if(node='{@current_node}'&dataset='{@dataset}';'{@new_node}';node)"/>
				<colord hide="node"/>
				<merge/>
				<willbe name="node" value="node_new"/>
				<colord cols="compid,dataset,node,access_start,access_end,redaction_start,redaction_end"/>
				<merge/>
			</ops>
		</do>
		<do>
			<set save_path="<%= root_path %>.system_data.filters" save_title="Filters"/>
		</do>
		<do><insert block="save"/></do>
	</block>

<note> Audit </note>
	<block name="log_transaction">
		<note> Add a record of a transaction. </note>
		<do action_="api" api_="dbupdate">
			<path>{@audit_path}</path>
		</do>
		<do action_="api" api_="query">
			<name>{@audit_path}</name>
			<ops>
				<base table="{@audit_path}"/>
				<merge table2="<%= root_path %>.system_data.dummy" match="order">
					<table depth="1"/>
					<willbe name="username" value="'{@username_}'"/>
					<willbe name="timestamp" value="{@now_}"/>
					<willbe name="action" value="'{@action}'"/>
				</merge>
			</ops>
		</do>
		<do><set save_path="{@audit_path}" save_title="{@log_table}"/></do>
		<insert block="save"/>
	</block>

	<block name="archive">
		<note> Save a snapshot of the table state for a transaction. </note>
		<do action_="api" api_="dbupdate">
			<path>{@archive_path}</path>
		</do>
		<do action_="api" api_="query">
			<name>{@archive_path}</name>
			<ops>
				<base table="{@archive_path}"/>
				<merge table2="{@table_to_archive}" match="pad">
					<willbe name="username" value="'{@username_}'"/>
					<willbe name="timestamp" value="{@now_}"/>
				</merge>
			</ops>
		</do>
		<do><set save_path="{@archive_path}" save_title="{@archive_table_name}"/></do>
		<insert block="save"/>
	</block>

	<block name="scheduled_backup">
		<note>Backup system data</note>
		<loop with_="table">
			<outer>
				<directory folder="<%= root_path %>.audit.system_data"/>
			</outer>
			<inner>
				<set dot_delim="{str_to_lst(@table.path;'.')}"/>
				<set table_name="{@dot_delim[lst_len(@dot_delim)]}"/>
				<base table="{@table.path}"/>
				<materialize path="<%= root_path %>.secure_location.system_data.{@table_name}_backup" replace="1" title="{@table_name}_backup"/>
			</inner>
		</loop>

		<note>Backup dataset configs</note>
		<loop with_="table">
			<outer>
				<directory folder="<%= root_path %>.audit.dataset_configs"/>
			</outer>
			<inner>
				<set dot_delim="{str_to_lst(@table.path;'.')}"/>
				<set table_name="{@dot_delim[lst_len(@dot_delim)]}"/>
				<base table="{@table.path}"/>
				<materialize path="<%= root_path %>.secure_location.dataset_configs.{@table_name}_backup" replace="1" title="{@table_name}_backup"/>
			</inner>
		</loop>
	</block>

<note> Utility </note>
	<block name="save">
		<note> Save a table </note>
		<do action_="api" api_="savetable">
			<name mode="replace">{@save_path}</name>
			<title>{@save_title}</title>
			<users type="inherit"/>
		</do>
		<note> Tell system about the change </note>
		<do action_="api" api_="dbupdate">
			<path>{@save_path}</path>
		</do>
	</block>

	<block name="compute_filters" hierarchies_table="">
		<note> Compute filters from access and hierarchies. </note>
		<link table2="{@hierarchies_table}" col="dataset,node" expand="1">
			<insert block="leaf_table" hierarchies_table="{@hierarchies_table}"/>
		</link>
		<colord hide="node"/>
		<merge/>
		<willbe name="node" value="leaf"/>
		<colord cols="compid,dataset,node,access_start,access_end,redaction_start,redaction_end"/>
	</block>

	<block name="write_filters">
		<note> Write filters based on current access. </note>
		<do action_="api" api_="dbupdate">
			<path><%= root_path %>.system_data.filters</path>
		</do>
		<do action_="api" api_="query">
			<name><%= root_path %>.system_data.filters</name>
			<ops>
				<base table="<%= root_path %>.system_data.access"/>
				<insert block="compute_filters" hierarchies_table="<%= root_path %>.system_data.hierarchies"/>
				<note> Add path column </note>
				<link table2="<%= root_path %>.system_data.raw_hierarchies" col="dataset,node" col2="d0,leaf" cols="path" shift="0">
				    <willbe name="leaf_pos_raw" value="r_position('d*';;'')-1"/>
				    <willbe name="leaf_pos" value="if(leaf_pos_raw=na;r_cnt('d*';);leaf_pos_raw)"/>
				    <willbe name="leaf" value="r_pick('d*';;leaf_pos)"/>
					<willbe name="path_raw" value="r_mapstring('d*';;rcv_;',')"/>
					<willbe name="path" value="strtake(path_raw;',';leaf_pos-1)"/>
					<willbe name="path" value="csl_drop(strtake(path_raw;',';leaf_pos-1);1)"/>
				</link>
			</ops>
		</do>
		<do><set save_path="<%= root_path %>.system_data.filters" save_title="Filters"/></do>
		<insert block="save"/>
		<do><set table_to_archive="<%= root_path %>.system_data.filters" archive_table_name="Filters Archive" archive_path="<%= root_path %>.audit.system_data.filters_archive"/></do>
		<insert block="archive"/>
	</block>

<note> Dataset </note>
	<block name="get_dataset">
		<note> Retrieve username </note>
		<willbe name="usr_dataset" value="'{userdata(;'uid')}'"/>
		<colord cols="usr_dataset"/>
	</block>

	<block name="authorized_hierarchy_modification_constraint">
		<note> Ensure user is allowed to make attempted change to hierarchy. </note>
		<do base_="<%= root_path %>.system_data.managers" value1_="@authorized_modification_flag" row1="1" col1="1">
			<sel value="user='{@usr_dataset}'"/>
			<willbe name="selected_dataset" value="'{@dataset}'"/>
			<willbe name="is_permissioned" value="selected_dataset=dataset"/>
			<tabu label="authorized_modification">
				<tcol fun="hi" source="is_permissioned"/>
			</tabu>
		</do>
		<do>
			<if test="{~@authorized_modification_flag}">
				<signal msg="Error: You are not authorized to make this change."/>
			</if>
		</do>
	</block>

	<block name="authorized_grant_constraint">
		<note> Ensure user is allowed to make attempted change to access. </note>
		<do base_="<%= root_path %>.system_data.access" value1_="@authorized_modification_flag" row1="1" col1="1">
			<insert block="grant_insertions" node_list="{@node_list}" company_list="{@company_list}"/>
			<tabu breaks="dataset">
				<tcol fun="cnt" source="dataset"/>
			</tabu>
			<link table2="<%= root_path %>.system_data.managers" col="dataset">
				<sel value="user='{@usr_dataset}'"/>
			</link>
			<willbe name="is_permissioned" value="user<>na"/>
			<tabu label="authorized_modification">
				<tcol fun="lo" source="is_permissioned"/>
			</tabu>
		</do>
		<do>
			<if test="{~@authorized_modification_flag}">
				<signal msg="Error: You are not authorized to make this change."/>
			</if>
		</do>
	</block>

	<block name="authorized_revoke_constraint">
		<note> Ensure user is allowed to make attempted change to access. </note>
		<do base_="<%= root_path %>.system_data.access" value1_="@authorized_modification_flag" row1="1" col1="1">
			<insert block="revoke_deletions" node_list="{@node_list}" company_list="{@company_list}"/>
			<tabu breaks="dataset">
				<tcol fun="cnt" source="dataset"/>
			</tabu>
			<link table2="<%= root_path %>.system_data.managers" col="dataset">
				<sel value="user='{@usr_dataset}'"/>
			</link>
			<willbe name="is_permissioned" value="user<>na"/>
			<tabu label="authorized_modification">
				<tcol fun="lo" source="is_permissioned"/>
			</tabu>
		</do>
		<do>
			<if test="{~@authorized_modification_flag}">
				<signal msg="Error: You are not authorized to make this change."/>
			</if>
		</do>
	</block>
</library>
